<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>Conway's Game of Life</title>
        <style type="text/css" mce_bogus="1">
            table {margin:auto;}
                </style>
    </head>
    <body>
       
        <table>
            <tr>
                <td align="left">Generation: <span id="spanGen">0</span>&nbsp;&nbsp;<a href="http://blog.csdn.net/lifegame/article/details/6385081" style="text-decoration:none">HTML5版本的生命游戏_Game of Life</a></td>
                <td align="right">
                     <a href="xiaoxu/school.html">xianxixiangmu</a>
                    <button id="btnStart" onclick="startGame();return true;">Start</button>
                    <button id="btnPause" onclick="pauseGame();return true;" disabled="disabled">Pause</button>
                    <button id="btnReset" onclick="resetGame();return true;" disabled="disabled">Reset</button>
                    <button id="btnRandom" onclick="randomGame();return true;">Random</button>
                    <button id="btnHelp" onclick="help();return true;">What's this?</button>
                </td>
            </tr>
            <tr align="center">
                <td colspan="2"><canvas id="space" width="1400" height="1400" style="border: 1px solid; background-color: #eeeeee;" /></td>
            </tr>
        </table>
    </body>
    <script type="text/javascript">
        var canvas = document.getElementById('space');
        var context = canvas.getContext('2d');
        var timerInterval = 10; // ms
        var cellWidth = 10; // please ensure: cellWidth > 2
        var cellXLen = 140;  // please ensure: cellWidth * cellXLen = 800
        var cellYLen = 140;  // please ensure: cellWidth * cellYLen = 800
        var cells = [];
        var running = 0;
        var generation = 0;

        function drawCell(x,y,state){
              var cx = x * cellWidth;
              var cy = y * cellWidth;
                if(state && state==1){
                    context.fillStyle = "Gold";
                    context.fillRect(cx, cy, cellWidth, cellWidth);
                    context.strokeStyle = "DarkGoldenRod";
                    context.strokeRect(cx+1, cy+1, cellWidth-2, cellWidth-2);
                }
                else{
                    context.clearRect(cx, cy, cellWidth, cellWidth);
                }
        }

        function drawPatterns(){
            function setCell(x,y){
                cells[[x,y]] = 1;
              drawCell(x, y, 1);
            }
            function drawGliderPattern(){
              setCell(21,70);
              setCell(22,70);
              setCell(23,70);
              setCell(24,70);
              setCell(25,70);
              setCell(26,70);
              setCell(27,70);
              setCell(28,70);
              setCell(29,70);
              setCell(30,70);
              setCell(31,70);
              setCell(32,70);
              setCell(33,70);
              setCell(34,70);
              setCell(35,70);
              setCell(36,70);
              setCell(37,70);
              setCell(38,70);
              setCell(39,70);
              setCell(40,70);
              setCell(41,70);
              setCell(42,70);
              setCell(43,70);
              setCell(44,70);
              setCell(45,70);
              setCell(46,70);
              setCell(47,70);
              setCell(48,70);
              setCell(49,70);
              setCell(50,70);
              setCell(51,70);
              setCell(52,70);
              setCell(53,70);
              setCell(54,70);
              setCell(55,70);
              setCell(56,70);
              setCell(57,70);
              setCell(58,70);
              setCell(59,70);
              setCell(60,70);
              setCell(61,70);
              setCell(62,70);
              setCell(63,70);
              setCell(64,70);
              setCell(65,70);
              setCell(66,70);
              setCell(67,70);
              setCell(68,70);
              setCell(69,70);
              setCell(70,70);
              setCell(71,70);
              setCell(72,70);
              setCell(73,70);
              setCell(74,70);
              setCell(75,70);
              setCell(76,70);
              setCell(77,70);
              setCell(78,70);
              setCell(79,70);
              setCell(80,70);
              setCell(81,70);
              setCell(82,70);
              setCell(83,70);
              setCell(84,70);
              setCell(85,70);
              setCell(86,70);
              setCell(87,70);
              setCell(88,70);
              setCell(89,70);
              setCell(90,70);
              setCell(91,70);
              setCell(92,70);
              setCell(93,70);
              setCell(94,70);
              setCell(95,70);
              setCell(96,70);
              setCell(97,70);
              setCell(98,70);
              setCell(99,70);
              setCell(100,70);
              setCell(101,70);
              setCell(102,70);
              setCell(103,70);
              setCell(104,70);
              setCell(105,70);
              setCell(106,70);
              setCell(107,70);
              setCell(108,70);
              setCell(109,70);
              setCell(110,70);
              setCell(111,70);
              setCell(112,70);
              setCell(113,70);
              setCell(114,70);
              setCell(115,70);
              setCell(116,70);
              setCell(117,70);
              setCell(118,70);
            }
            drawGliderPattern();
        }

        function applyRule(x,y){
                var neighbours = [];
                var neighbourCount = 0;
                var currentState = cells[[x,y]];
                var nextState = 0;
                neighbours[0] = cells[[(x-1+cellXLen)%cellXLen, (y-1+cellYLen)%cellYLen]];
                neighbours[1] = cells[[(x-1+cellXLen)%cellXLen, (y+1+cellYLen)%cellYLen]];
                neighbours[2] = cells[[(x+cellXLen)%cellXLen, (y+1+cellYLen)%cellYLen]];
                neighbours[3] = cells[[(x+cellXLen)%cellXLen, (y-1+cellYLen)%cellYLen]];
                neighbours[4] = cells[[(x+1+cellXLen)%cellXLen, (y+1+cellYLen)%cellYLen]];
                neighbours[5] = cells[[(x+1+cellXLen)%cellXLen, (y-1+cellYLen)%cellYLen]];
                neighbours[6] = cells[[(x+1+cellXLen)%cellXLen, (y+cellYLen)%cellYLen]];
                neighbours[7] = cells[[(x-1+cellXLen)%cellXLen, (y+cellYLen)%cellYLen]];
                for(i=0;i<8;i++){
                    state = neighbours[i];
                    if(state && state==1) neighbourCount++;
                }
                if(currentState && currentState==1){
                    if(neighbourCount<2 || neighbourCount>3) return 0;
                    else return 1;
                }
                else{
                    if(neighbourCount==3) return 1;
                    else return 0;
                }
        }

        function loadGame(){
            canvas.onmousedown = function(e){
                if(running==1) return;
                if(e.offsetX) {
                              x = e.offsetX;
                              y = e.offsetY;
                        }
                        else if(e.layerX) {
                          x = e.layerX;
                          y = e.layerY;
                        }
                x = Math.floor(x / cellWidth);
                y = Math.floor(y / cellWidth);
                state = cells[[x,y]];
                if(state && state==1)
                {
                    cells[[x,y]] = 0;
                    drawCell(x, y, 0);
                }
                else
                {
                    cells[[x,y]] = 1;
                    drawCell(x, y, 1);
              }
            }
            drawPatterns();
        }

        function startGame(){
            function runGame(){
                var nextgen = [];
                for(x=0;x<cellXLen;x++){
                    for(y=0;y<cellYLen;y++){
                        nextgen[[x,y]] = applyRule(x,y);
                    }
                }
                for(x=0;x<cellXLen;x++){
                    for(y=0;y<cellYLen;y++){
                        cells[[x,y]] = nextgen[[x,y]];
                    }
                }
                for(x=0;x<cellXLen;x++){
                    for(y=0;y<cellYLen;y++){
                        drawCell(x, y, cells[[x,y]]);
                    }
                }
                generation++;
                spanGen.innerHTML = generation;
              if(running==1) setTimeout(runGame, timerInterval);
            }
            btnStart.disabled = true;
            btnPause.disabled = false;
            btnReset.disabled = true;
            btnRandom.disabled = true;
            running = 1;
            runGame();
        }

        function pauseGame(){
            running = 0;
            btnStart.disabled = false;
            btnPause.disabled = true;
            btnReset.disabled = false;
            btnRandom.disabled = false;
        }

        function resetGame(){
            for(x=0;x<cellXLen;x++){
                    for(y=0;y<cellYLen;y++){
                        cells[[x,y]] = 0;
                        drawCell(x,y,0);
                    }
                }
            drawPatterns();
            generation = 0;
            spanGen.innerHTML = generation;
        }

        function randomGame(){
            for(x=0;x<cellXLen;x++){
                    for(y=0;y<cellYLen;y++){
                        s = (Math.random()>=0.8) ? 1 : 0;
                        cells[[x,y]] = s;
                        drawCell(x,y,s);
                    }
                }
            generation = 0;
            spanGen.innerHTML = generation;
        }

        function help(){
            window.open("http://en.wikipedia.org/wiki/Conway's_Game_of_Life");
        }

        window.addEventListener("load", loadGame, true);
 </script>
<html>
